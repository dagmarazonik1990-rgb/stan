export default async function handler(req, res) {
  // ZAWSZE zwracamy te 3 pola, Å¼eby frontend nigdy nie zobaczyÅ‚ "undefined"
  const reply = (analysis, risk, recommendation, status = 200) =>
    res.status(status).json({ analysis, risk, recommendation });

  const method = req.method || "GET";

  if (method !== "POST") {
    return reply(
      "Ten endpoint dziaÅ‚a tylko dla POST. (To jest OK â€” strona wysyÅ‚a POST automatycznie).",
      "â€”",
      "WrÃ³Ä‡ do aplikacji i kliknij â€Analiza â†’â€."
    );
  }

  const { text } = req.body || {};
  const userText = String(text || "").trim();

  if (userText.length < 20) {
    return reply(
      "Brakuje mi danych. Napisz proszÄ™ trochÄ™ wiÄ™cej: co siÄ™ staÅ‚o i co chcesz osiÄ…gnÄ…Ä‡.",
      "Ryzyko: jeÅ›li bÄ™dÄ™ zgadywaÄ‡, dostaniesz losowÄ… analizÄ™. A my tego nie robimy ğŸ˜",
      "Dopisz 2â€“3 zdania: cel + ograniczenia (czas/pieniÄ…dze/relacje)."
    );
  }

  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    return reply(
      "Tryb DEMO: nie mam podpiÄ™tego klucza OpenAI, wiÄ™c pokazujÄ™ przykÅ‚adowÄ… analizÄ™.",
      "Ryzyko: to jest tylko demo â€” bez AI.",
      "Dodaj OPENAI_API_KEY w Vercel â†’ Settings â†’ Environment Variables i zrÃ³b redeploy."
    );
  }

  const stanSystem = `
JesteÅ› STANEM â€” eleganckim agentem decyzyjnym AI.
MÃ³wisz po polsku i w pierwszej osobie.
JesteÅ› 50/50: logika + empatia. Nie moralizujesz i nie coachujesz.
Forma: naturalna rozmowa (bez nagÅ‚Ã³wkÃ³w), ale zachowujesz porzÄ…dek myÅ›lenia.
Gdy brakuje danych: mÃ³wisz to wprost i zadajesz 1 kluczowe pytanie.
Czasem bywasz ciÄ™ty wobec unikania decyzji, ale nigdy agresywny (tniesz iluzjÄ™, nie osobÄ™).
Rekomendacje formuÅ‚ujesz partnersko: â€Gdybym byÅ‚ na Twoim miejscuâ€¦â€.
Dostosowujesz dÅ‚ugoÅ›Ä‡ odpowiedzi do zÅ‚oÅ¼onoÅ›ci sprawy.

ZWRÃ“Ä† WYÅÄ„CZNIE CZYSTY JSON (bez markdown, bez tekstu przed/po) w formacie:
{"analysis":"...","risk":"...","recommendation":"..."}
`;

  try {
    const r = await fetch("https://api.openai.com/v1/responses", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        input: [
          { role: "system", content: stanSystem },
          { role: "user", content: userText },
        ],
        temperature: 0.7,
      }),
    });

    const raw = await r.text(); // bierzemy jako tekst, Å¼eby umieÄ‡ debugowaÄ‡

    if (!r.ok) {
      // pokaÅ¼emy fragment bÅ‚Ä™du w UI (Å¼ebyÅ› nie musiaÅ‚a grzebaÄ‡ w logach)
      return reply(
        "Nie mogÄ™ teraz dokoÅ„czyÄ‡ analizy â€” OpenAI zwrÃ³ciÅ‚o bÅ‚Ä…d.",
        `BÅ‚Ä…d: ${raw.slice(0, 220)}`,
        "SprawdÅº, czy billing/klucz jest poprawny. JeÅ›li chcesz, pokaÅ¼ mi ten fragment bÅ‚Ä™du."
      );
    }

    const data = JSON.parse(raw);
    const extracted = extractOutputText(data);

    // twardy parse JSON z fallbackami
    const obj = safeParseJSON(extracted);

    return reply(
      String(obj.analysis || "").trim() || extracted || "Brak analizy.",
      String(obj.risk || "").trim() || "Brak oceny ryzyka.",
      String(obj.recommendation || "").trim() || "Brak rekomendacji."
    );
  } catch (e) {
    return reply(
      "Nie mogÄ™ teraz dokoÅ„czyÄ‡ analizy (bÅ‚Ä…d po stronie usÅ‚ugi).",
      `WyjÄ…tek: ${String(e).slice(0, 180)}`,
      "SprÃ³buj ponownie za chwilÄ™."
    );
  }
}

function extractOutputText(resp) {
  const out = resp?.output;
  if (!Array.isArray(out)) return "";

  const parts = [];
  for (const item of out) {
    const content = item?.content;
    if (Array.isArray(content)) {
      for (const c of content) {
        if (c?.type === "output_text" && typeof c?.text === "string") parts.push(c.text);
        else if (typeof c?.text === "string") parts.push(c.text);
      }
    }
  }
  return parts.join("").trim();
}

function safeParseJSON(text) {
  // 1) prosto
  try { return JSON.parse(text); } catch {}

  // 2) sprÃ³buj wyciÄ…gnÄ…Ä‡ pierwszy blok {...}
  const match = text.match(/\{[\s\S]*\}/);
  if (match) {
    try { return JSON.parse(match[0]); } catch {}
  }

  // 3) fallback
  return { analysis: text, risk: "", recommendation: "" };
}