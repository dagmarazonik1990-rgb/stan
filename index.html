<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>STAN</title>

<style>
:root{
  --bg:#070A12;
  --bg2:#0B0F1A;
  --text:#EAF0FF;
  --muted:rgba(234,240,255,0.65);
  --a1:#7B5CFF;
  --a2:#B256FF;

  --orbGlow1: rgba(123,92,255,0.40);
  --orbGlow2: rgba(178,86,255,0.35);

  --ritual: 0; /* 0/1 ustawiane JS-em */
}

*{box-sizing:border-box;}
html,body{height:100%;}

body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  color:var(--text);
  background:
    radial-gradient(900px 600px at 70% 15%, rgba(178,86,255,0.18), transparent 60%),
    linear-gradient(180deg,var(--bg),var(--bg2));
  padding:22px 16px 40px;
  transition: filter 400ms ease, background 400ms ease;
}

.wrap{max-width:560px;margin:auto;}
.title{font-size:54px;font-weight:900;margin:0 0 4px;}
.subtitle{color:var(--muted);margin:0 0 18px;}

/* ===== avatar box: bez ramek ===== */
.avatarBox{
  width:100%;
  aspect-ratio:1/1;
  border-radius:28px;
  overflow:hidden;
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
  margin-bottom:16px;
  background: transparent;
}

/* ===== ORB ===== */
.orb{
  width:72%;
  aspect-ratio:1/1;
  border-radius:50%;
  position:relative;

  background:
    radial-gradient(circle at 35% 30%, rgba(255,255,255,0.18), transparent 45%),
    radial-gradient(circle at 50% 55%, rgba(178,86,255,0.45), transparent 60%),
    radial-gradient(circle at 50% 50%, rgba(123,92,255,0.75), #141422 70%, #000 100%);

  box-shadow:
    0 0 90px var(--orbGlow1),
    0 0 160px var(--orbGlow2);

  animation: orbBreath 6s ease-in-out infinite;
  transition: transform .25s ease, box-shadow .25s ease, filter .25s ease;
}

@keyframes orbBreath{
  0%{transform:scale(1);}
  50%{transform:scale(1.06);}
  100%{transform:scale(1);}
}

.orb:after{
  content:"";
  position:absolute;
  left:-10%;
  right:-10%;
  height:2px;
  background:linear-gradient(90deg,transparent,rgba(255,255,255,0.8),transparent);
  animation: scan 5s linear infinite;
  opacity:0.6;
}
@keyframes scan{
  0%{top:15%;}
  50%{top:85%;}
  100%{top:15%;}
}

/* ===== SEMI ===== */
.semi{
  width:100%;
  height:100%;
  object-fit:cover;
  object-position:center 20%;
  animation:breathe 8s ease-in-out infinite;
  transform: scale(1.03);
  filter: saturate(1.05) contrast(1.02);
  will-change: transform;
}

@keyframes breathe{
  0%{transform:scale(1.03);}
  50%{transform:scale(1.06);}
  100%{transform:scale(1.03);}
}

/* overlay ‚Äúpresence‚Äù ‚Äì delikatny glow bez ramek */
.presenceGlow{
  position:absolute;
  inset:-15%;
  background:
    radial-gradient(closest-side at 50% 45%, rgba(123,92,255,0.18), transparent 62%),
    radial-gradient(closest-side at 55% 55%, rgba(178,86,255,0.12), transparent 66%);
  filter: blur(18px);
  opacity: 0.75;
  pointer-events:none;
  mix-blend-mode: screen;
}

/* oczy */
.eyes{
  position:absolute;
  top:42%;
  left:50%;
  transform:translateX(-50%);
  width:120px;
  display:flex;
  justify-content:space-between;
  pointer-events:none;
}

.eye{
  width:14px;height:14px;border-radius:50%;
  background:#4de0ff;
  box-shadow:0 0 12px #4de0ff;
  animation: blink 14s infinite;
  transition: transform 180ms ease;
}
@keyframes blink{
  0%,97%,100%{transform:scaleY(1);}
  98%{transform:scaleY(0.1);}
}

/* ===== inputs ===== */
textarea{
  width:100%;
  min-height:110px;
  border-radius:18px;
  border:none;
  background:rgba(0,0,0,0.25);
  color:white;
  padding:14px;
  font-size:16px;
  margin-bottom:12px;
  outline:none;
}

button{
  width:100%;
  padding:16px;
  border:none;
  border-radius:18px;
  font-size:18px;
  font-weight:800;
  color:white;
  background:linear-gradient(90deg,var(--a1),var(--a2));
  cursor:pointer;
  margin-bottom:10px;
}

.row{
  display:flex;
  gap:10px;
}
.row button{
  flex:1;
  background:rgba(255,255,255,0.07);
  border:1px solid rgba(255,255,255,0.10);
  margin-bottom:0;
}
.row button.primary{
  background:linear-gradient(90deg,var(--a1),var(--a2));
  border:none;
}

.card{
  margin-top:14px;
  padding:14px;
  border-radius:18px;
  background:rgba(255,255,255,0.05);
  border:1px solid rgba(255,255,255,0.08);
}

h3{margin:0 0 6px 0;}
.text{white-space:pre-wrap;color:var(--muted);margin:0;}

/* ===== Ritual Dark (auto po 22) ===== */
body.ritual{
  filter: saturate(0.95) brightness(0.92) contrast(1.05);
}
body.ritual .subtitle{ color: rgba(234,240,255,0.55); }
body.ritual .orb{
  animation-duration: 8s;
  filter: saturate(0.9) brightness(0.95);
  box-shadow:
    0 0 70px rgba(90,70,160,0.35),
    0 0 120px rgba(120,60,160,0.22);
}
body.ritual .presenceGlow{
  opacity: 0.55;
}
</style>
</head>

<body>
<div class="wrap">
  <div class="title">STAN</div>
  <div class="subtitle">Agent decyzyjny AI ‚Ä¢ obecno≈õƒá</div>

  <div class="avatarBox" id="avatarBox" aria-label="STAN avatar">
    <div class="orb" id="orb"></div>
  </div>

  <textarea id="input" placeholder="Opisz sytuacjƒô..."></textarea>

  <button class="primary" onclick="run()">Analiza ‚Üí</button>

  <div class="row">
    <button onclick="toggleAvatar()">üëÅ Avatar</button>
    <button onclick="toggleAmbient()">üåå Ambient</button>
    <button onclick="stopAmbient()">‚èπ Stop</button>
  </div>

  <div class="card">
    <h3>Analiza</h3>
    <p class="text" id="analysis">‚Äî</p>
  </div>

  <div class="card">
    <h3>Ryzyko</h3>
    <p class="text" id="risk">‚Äî</p>
  </div>

  <div class="card">
    <h3>Rekomendacja</h3>
    <p class="text" id="rec">‚Äî</p>
  </div>
</div>

<script>
/* =========================
   Ritual Dark auto po 22:00
========================= */
function applyRitualByTime(){
  const hour = new Date().getHours();
  // Ritual od 22 do 5:59
  const ritual = (hour >= 22 || hour < 6);
  document.body.classList.toggle("ritual", ritual);
}
applyRitualByTime();
setInterval(applyRitualByTime, 60 * 1000);

/* =========================
   Avatar switch: orb <-> semi
   Semi plik: avatar-semi.png
========================= */
let mode = "orb";
const avatarBox = document.getElementById("avatarBox");

function renderOrb(){
  avatarBox.innerHTML = `<div class="orb" id="orb"></div>`;
  mode = "orb";
}

function renderSemi(){
  avatarBox.innerHTML = `
    <img src="avatar-semi.png" class="semi" id="semi">
    <div class="presenceGlow"></div>
    <div class="eyes" id="eyes">
      <div class="eye"></div>
      <div class="eye"></div>
    </div>
  `;
  mode = "semi";
  // po renderze odpal tracking spojrzenia
  setupGazeTracking();
}

function toggleAvatar(){
  if(mode === "orb") renderSemi();
  else renderOrb();
}

/* =========================
   Semi patrzy za kursorem/palcem
========================= */
let gazeSetupDone = false;

function setupGazeTracking(){
  // nie rejestruj 100x listener√≥w
  if(gazeSetupDone) return;
  gazeSetupDone = true;

  function updateGaze(clientX, clientY){
    if(mode !== "semi") return;
    const eyesWrap = document.getElementById("eyes");
    if(!eyesWrap) return;

    const rect = avatarBox.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    const dx = (clientX - cx) / rect.width;
    const dy = (clientY - cy) / rect.height;

    const max = 6; // px
    const x = Math.max(-1, Math.min(1, dx)) * max;
    const y = Math.max(-1, Math.min(1, dy)) * max;

    const eyes = avatarBox.querySelectorAll(".eye");
    eyes.forEach(e => {
      e.style.transform = `translate(${x}px, ${y}px)`;
    });
  }

  window.addEventListener("mousemove", (e)=> updateGaze(e.clientX, e.clientY), {passive:true});
  window.addEventListener("touchmove", (e)=>{
    if(!e.touches || !e.touches[0]) return;
    updateGaze(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive:true});
}

/* =========================
   Scroll: subtelny drift
========================= */
window.addEventListener("scroll", ()=>{
  const y = window.scrollY * 0.01;
  const orb = document.querySelector(".orb");
  const semi = document.getElementById("semi");

  if(orb){
    orb.style.transform = `translateY(${y}px) scale(1.03)`;
  }
  if(semi){
    semi.style.transform = `translateY(${y}px) scale(1.04)`;
  }
}, {passive:true});

/* =========================
   Tryb skupienia przy analizie
========================= */
function focusMode(){
  document.body.style.filter = "brightness(0.93)";
  setTimeout(()=>{ document.body.style.filter = ""; }, 900);
}

/* =========================
   STAN DEMO (bez API)
========================= */
function run(){
  const t = (document.getElementById("input").value || "").trim();

  if(t.length < 40){
    document.getElementById("analysis").textContent =
      "Za ma≈Ço danych. Podaj: cel + ograniczenia + 2 opcje (A/B).";
    document.getElementById("risk").textContent =
      "Ryzyko: zgadywanie. A ja nie zgadujƒô.";
    document.getElementById("rec").textContent =
      "Dopisz 3 kr√≥tkie zdania i kliknij Analiza jeszcze raz.";
    reactAmbient();
    return;
  }

  focusMode();

  document.getElementById("analysis").textContent =
    "Oddziel fakty od emocji. Teraz potrzebujƒô kryteri√≥w wyboru.";
  document.getElementById("risk").textContent =
    "Najwiƒôksze ryzyko: decyzja pod wp≈Çywem impulsu lub bez kryteri√≥w.";
  document.getElementById("rec").textContent =
    "Plan: 3 kryteria ‚Üí ocena A/B (1‚Äì10) ‚Üí 1 mikro-test ‚Üí decyzja w 7 dni.";

  reactAmbient();
}

/* =========================
   Ambient: WebAudio (stereo p≈Çywanie)
   100% bezkosztowo
========================= */
let audioCtx = null;
let masterGain = null;
let panner = null;
let osc1 = null;
let osc2 = null;
let noiseNode = null;
let ambientOn = false;

function initAmbient(){
  if(audioCtx) return;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.00; // start od zera

  // stereo panner
  panner = audioCtx.createStereoPanner();
  panner.pan.value = 0;

  // oscylatory
  osc1 = audioCtx.createOscillator();
  osc1.type = "sine";
  osc1.frequency.value = 42;

  osc2 = audioCtx.createOscillator();
  osc2.type = "triangle";
  osc2.frequency.value = 63;

  // delikatny noise
  const bufferSize = 2 * audioCtx.sampleRate;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++){
    data[i] = (Math.random()*2 - 1) * 0.15;
  }

  const noiseSource = audioCtx.createBufferSource();
  noiseSource.buffer = noiseBuffer;
  noiseSource.loop = true;

  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = "lowpass";
  noiseFilter.frequency.value = 280;

  // ≈ÇƒÖczenia
  osc1.connect(panner);
  osc2.connect(panner);
  noiseSource.connect(noiseFilter);
  noiseFilter.connect(panner);

  panner.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  osc1.start();
  osc2.start();
  noiseSource.start();

  // stereo drift (A)
  setInterval(()=>{
    if(!ambientOn) return;
    const t = audioCtx.currentTime;

    // p≈Çywanie stereo
    panner.pan.value = Math.sin(t * 0.20) * 0.38;

    // mikro falowanie czƒôstotliwo≈õci (≈ºycie)
    osc1.frequency.linearRampToValueAtTime(40 + Math.random()*4, t + 2.5);
    osc2.frequency.linearRampToValueAtTime(60 + Math.random()*5, t + 2.5);

  }, 60);
}

function toggleAmbient(){
  initAmbient();
  ambientOn = !ambientOn;

  const base = document.body.classList.contains("ritual") ? 0.022 : 0.030;

  if(ambientOn){
    masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
    masterGain.gain.linearRampToValueAtTime(base, audioCtx.currentTime + 0.6);
  }else{
    masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
    masterGain.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + 0.6);
  }
}

function stopAmbient(){
  if(!audioCtx) return;
  ambientOn = false;
  masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
  masterGain.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + 0.25);
}

function reactAmbient(){
  if(!audioCtx || !ambientOn) return;

  const boost = document.body.classList.contains("ritual") ? 0.040 : 0.060;
  const base  = document.body.classList.contains("ritual") ? 0.022 : 0.030;

  masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
  masterGain.gain.linearRampToValueAtTime(boost, audioCtx.currentTime + 0.25);
  setTimeout(()=>{
    masterGain.gain.linearRampToValueAtTime(base, audioCtx.currentTime + 0.8);
  }, 450);
}

/* start orb */
renderOrb();
</script>

</body>
</html>