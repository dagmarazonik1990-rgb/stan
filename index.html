<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>STAN</title>

<meta name="theme-color" content="#0B0F1A" />
<link rel="manifest" href="manifest.json" />

<style>
:root{
  --bg:#0B0F1A;
  --surface:#111827;
  --text:#E5E7EB;

  /* default orb colors */
  --orbCore:#9F7AEA;
  --orbMid:#6D5DF6;
  --orbEdge:#1A1F3A;

  --accent1:#6D5DF6;
  --accent2:#A855F7;
}

*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
  background:
    radial-gradient(circle at 30% 20%, #1A1F3A 0%, #0B0F1A 60%);
  color:var(--text);
  min-height:100vh;
  padding:20px;
}
h1{font-size:34px;font-weight:800; letter-spacing:.5px}
.subtitle{opacity:.7;margin-bottom:16px}

.wrap{
  max-width:720px;
  margin:0 auto;
}

/* ===== ORB ===== */
.stan-visual-wrap{
  width:100%;
  display:flex;
  justify-content:center;
  margin:18px 0 14px;
}
.orb{
  width:260px;
  height:260px;
  border-radius:50%;
  background:
    radial-gradient(circle at 50% 50%,
      var(--orbCore) 0%,
      var(--orbMid) 40%,
      var(--orbEdge) 72%);
  box-shadow:
    0 0 40px rgba(120,90,255,0.55),
    0 0 120px rgba(120,90,255,0.25);
  animation: pulse 4s ease-in-out infinite;
  position:relative;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.06);
}

.orb::after{
  content:"";
  position:absolute;
  top:50%;
  left:-10%;
  width:120%;
  height:3px;
  background:linear-gradient(90deg, rgba(255,255,255,.15), rgba(255,255,255,.9), rgba(255,255,255,.15));
  transform:translateY(-50%);
  opacity:.75;
  filter: blur(.3px);
}

@keyframes pulse{
  0%{transform:scale(1)}
  50%{transform:scale(1.05)}
  100%{transform:scale(1)}
}

.orb.active{
  animation: intensePulse 1.1s ease-in-out infinite;
}
@keyframes intensePulse{
  0%{transform:scale(1)}
  50%{transform:scale(1.1)}
  100%{transform:scale(1)}
}

/* ===== INPUT ===== */
textarea{
  width:100%;
  height:120px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.03);
  padding:15px;
  color:var(--text);
  margin-top:10px;
  font-size:15px;
  line-height:1.35;
  outline:none;
}
textarea:focus{
  border-color: rgba(168,85,247,.35);
  box-shadow: 0 0 0 4px rgba(168,85,247,.10);
}

button.primary{
  width:100%;
  margin-top:16px;
  padding:14px 16px;
  border:none;
  border-radius:14px;
  font-size:16px;
  font-weight:750;
  background:linear-gradient(90deg,var(--accent1),var(--accent2));
  color:white;
}

.chips{
  margin-top:12px;
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  opacity:.9;
}
.chip{
  padding:8px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.03);
  font-size:13px;
}
.chip.ok{
  border-color: rgba(34,197,94,.35);
  box-shadow: 0 0 0 3px rgba(34,197,94,.08) inset;
}
.chip.warn{
  border-color: rgba(245,158,11,.35);
  box-shadow: 0 0 0 3px rgba(245,158,11,.08) inset;
}

.section{
  margin-top:18px;
  padding:16px;
  border-radius:16px;
  background:rgba(255,255,255,.04);
  border:1px solid rgba(255,255,255,.06);
}
.section h3{
  margin-bottom:8px;
  font-size:20px;
  letter-spacing:.2px;
}
.muted{opacity:.75}

.actions{
  display:flex;
  gap:10px;
  margin-top:14px;
}
button.secondary{
  flex:1;
  padding:12px 14px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.03);
  color:var(--text);
  font-weight:650;
}
.small{
  font-size:12px;
  opacity:.72;
  margin-top:10px;
}

/* nice smooth transitions for orb color changes */
.orb{
  transition: background 260ms ease, box-shadow 260ms ease;
}
</style>
</head>

<body>
<div class="wrap">
  <h1>STAN</h1>
  <div class="subtitle">Agent decyzyjny AI</div>

  <div class="stan-visual-wrap">
    <div class="orb" id="orb" aria-label="STAN Orb"></div>
  </div>

  <textarea id="input" placeholder="Opisz sytuację. Co się stało? Co chcesz osiągnąć? Jakie masz ograniczenia?"></textarea>

  <button class="primary" onclick="analyze()">Analiza →</button>

  <div class="chips">
    <div class="chip" id="chipMode">Tryb: DEMO (bez API)</div>
    <div class="chip" id="chipPWA">PWA: ?</div>
    <div class="chip" id="chipVersion">Wersja: 20260219-02</div>
    <div class="chip warn" id="chipMemory">Pamięć: aktywna</div>
  </div>

  <div class="section">
    <h3>Analiza</h3>
    <div id="analysis" class="muted">Tu pojawi się analiza.</div>
  </div>

  <div class="section">
    <h3>Ryzyko</h3>
    <div id="risk" class="muted">Tu pojawi się ocena ryzyka.</div>
  </div>

  <div class="section">
    <h3>Rekomendacja</h3>
    <div id="recommendation" class="muted">Tu pojawi się rekomendacja.</div>

    <div class="actions">
      <button class="secondary" onclick="forceRefresh()">Wymuś odświeżenie</button>
      <button class="secondary" onclick="clearMemory()">Wyczyść pamięć</button>
    </div>
    <div class="small">
      STAN w DEMO nie wysyła danych na serwer. Uczy się lokalnie w Twojej przeglądarce (localStorage).
    </div>
  </div>
</div>

<script>
/* =========================
   PWA indicator
========================= */
(function(){
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches
    || window.navigator.standalone === true;
  const chipPWA = document.getElementById("chipPWA");
  chipPWA.textContent = "PWA: " + (isStandalone ? "TAK" : "NIE");
  chipPWA.classList.toggle("ok", isStandalone);
})();

/* =========================
   Local “learning” memory
========================= */
const MEM_KEY = "stan_memory_v1";

function loadMem(){
  try{
    const raw = localStorage.getItem(MEM_KEY);
    if(!raw) return {
      runs: 0,
      vagueCount: 0,
      lastTopic: null,
      topicCounts: {},
      tonePreference: "helper_confront", // default
      lastEmotion: null
    };
    return JSON.parse(raw);
  }catch{
    return {
      runs: 0,
      vagueCount: 0,
      lastTopic: null,
      topicCounts: {},
      tonePreference: "helper_confront",
      lastEmotion: null
    };
  }
}

function saveMem(mem){
  localStorage.setItem(MEM_KEY, JSON.stringify(mem));
}

function clearMemory(){
  localStorage.removeItem(MEM_KEY);
  document.getElementById("analysis").innerText = "Pamięć wyczyszczona. STAN wrócił do ustawień domyślnych.";
  document.getElementById("risk").innerText = "-";
  document.getElementById("recommendation").innerText = "Wpisz sytuację i kliknij „Analiza →”.";
}

/* =========================
   Emotion / intent detection
   (simple heuristics, no API)
========================= */
const LEX = {
  anger: ["wkur", "wkurwia", "wściek", "nienaw", "chuj", "idiot", "zjeb", "mam dość", "podłość", "jeb", "kurw"],
  fear: ["boję", "strach", "lęk", "panik", "nie dam rady", "przeraż", "ryzyko", "utrata", "katastrof"],
  sadness: ["smut", "płacz", "samot", "bez sensu", "przygnęb", "żal", "depres"],
  indecision: ["nie wiem", "trudno mi", "zastanawiam", "chyba", "może", "niby", "jakoś", "nie jestem pewna"],
  urgency: ["teraz", "natychmiast", "już", "muszę", "dziś", "zaraz", "pilne"],
  relationship: ["partner", "związek", "relacja", "mąż", "żona", "on", "ona", "kłótn", "obraża", "cisza"],
  work: ["praca", "szef", "firma", "etat", "wypalen", "projekt", "zarabia", "klient"],
  money: ["pienią", "kasa", "dług", "kredyt", "czynsz", "rachunk", "budżet", "dochód"],
  health: ["zdrow", "sen", "ból", "lekarz", "chor", "stres", "lęk"]
};

function scoreLex(text){
  const t = text.toLowerCase();
  const score = {};
  for(const k of Object.keys(LEX)){
    score[k] = 0;
    for(const w of LEX[k]){
      if(t.includes(w)) score[k] += 1;
    }
  }
  return score;
}

function pickEmotion(score){
  // decide primary emotion among anger/fear/sadness, else neutral
  const max = Math.max(score.anger, score.fear, score.sadness);
  if(max === 0) return "neutral";
  if(max === score.anger) return "anger";
  if(max === score.fear) return "fear";
  return "sadness";
}

function pickTopic(score){
  // pick topic by highest among relationship/work/money/health, else general
  const candidates = ["relationship","work","money","health"];
  let best = "general";
  let bestV = 0;
  for(const c of candidates){
    if(score[c] > bestV){
      bestV = score[c];
      best = c;
    }
  }
  return best;
}

/* =========================
   Orb color mapping
========================= */
function setOrbByEmotion(emotion){
  const root = document.documentElement;
  const orb = document.getElementById("orb");

  // Colors are deliberate but no external dependency.
  // anger -> hot magenta, fear -> cyan/blue, sadness -> violet, neutral -> indigo
  if(emotion === "anger"){
    root.style.setProperty("--orbCore", "#F472B6");
    root.style.setProperty("--orbMid",  "#A855F7");
    root.style.setProperty("--orbEdge", "#1A0B2E");
    orb.style.boxShadow = "0 0 55px rgba(244,114,182,.55), 0 0 140px rgba(168,85,247,.25)";
  } else if(emotion === "fear"){
    root.style.setProperty("--orbCore", "#67E8F9");
    root.style.setProperty("--orbMid",  "#3B82F6");
    root.style.setProperty("--orbEdge", "#07162B");
    orb.style.boxShadow = "0 0 55px rgba(103,232,249,.45), 0 0 140px rgba(59,130,246,.22)";
  } else if(emotion === "sadness"){
    root.style.setProperty("--orbCore", "#A78BFA");
    root.style.setProperty("--orbMid",  "#6366F1");
    root.style.setProperty("--orbEdge", "#0B1028");
    orb.style.boxShadow = "0 0 55px rgba(167,139,250,.40), 0 0 140px rgba(99,102,241,.18)";
  } else {
    // neutral
    root.style.setProperty("--orbCore", "#9F7AEA");
    root.style.setProperty("--orbMid",  "#6D5DF6");
    root.style.setProperty("--orbEdge", "#1A1F3A");
    orb.style.boxShadow = "0 0 40px rgba(120,90,255,0.55), 0 0 120px rgba(120,90,255,0.25)";
  }
}

/* =========================
   STAN response generator
   (confronting, helpful, pushes for decision)
========================= */
function isVague(text, score){
  const t = text.toLowerCase();
  if(t.trim().length < 40) return true;
  if(score.indecision >= 2 && (score.relationship + score.work + score.money + score.health) === 0) return true;
  return false;
}

function buildOptions(topic){
  // STAN proposes options itself (user preference)
  if(topic === "relationship"){
    return {
      A: "Konfrontacja spokojna: jedna rozmowa 15–20 min z jasnymi zasadami (bez ucieczki, bez obrażania).",
      B: "Granica i konsekwencja: jeśli znowu ucieka/obraża — przerywasz rozmowę i wracasz do tematu dopiero w ustalonym terminie."
    };
  }
  if(topic === "work"){
    return {
      A: "Minimalny ruch: tydzień testów projektu po godzinach + mierniki (czas, koszt, efekt).",
      B: "Decyzja kontrolowana: 30 dni budowy MVP, ale z limitem godzin i warunkiem stop/go."
    };
  }
  if(topic === "money"){
    return {
      A: "Stabilizacja: tniesz ryzyko i robisz plan spłaty/cięć na 30 dni.",
      B: "Kontrolowane ryzyko: budżet eksperymentu (mały, stały) i twarde progi zatrzymania."
    };
  }
  if(topic === "health"){
    return {
      A: "Regeneracja jako priorytet: sen/rytuał/objawy + minimum 7 dni.",
      B: "Diagnoza: zapisujesz objawy i umawiasz konkretną konsultację/plan."
    };
  }
  return {
    A: "Opcja A: idziesz w mały, bezpieczny krok (test), zamiast skoku na główkę.",
    B: "Opcja B: podejmujesz decyzję z warunkami (progiem stop/go), zamiast ciągnąć temat w nieskończoność."
  };
}

function stanVoice(mem, emotion, topic, score, text){
  // core voice: elegant, helpful, sometimes ruthless with vagueness
  const t = text.trim();

  const options = buildOptions(topic);

  const wantsPlan = t.toLowerCase().includes("plan") || t.toLowerCase().includes("7") || t.toLowerCase().includes("30");
  const urgent = score.urgency > 0;
  const angry = emotion === "anger";

  // learning: if user often vague -> stronger push
  const pushLevel = Math.min(3, Math.floor(mem.vagueCount / 2));

  let analysis = "";
  let risk = "";
  let rec = "";

  // Analysis – short, pointed, not therapy
  analysis += "Dobra. Zatrzymuję chaos na chwilę.\n";
  analysis += "Widzę emocje (" + (emotion==="neutral" ? "neutralnie" : emotion) + "), ale nie będę prowadzić Cię za rękę bez faktów.\n";
  analysis += "To jest temat decyzyjny: wybór, granice, konsekwencje.\n";
  if(urgent) analysis += "Wątek ma presję czasu — tym bardziej nie robimy ruchu w afekcie.\n";
  if(angry) analysis += "Masz prawo być wkurzona. I właśnie dlatego Twoja decyzja musi być czysta.\n";

  // Risk
  if(emotion === "anger"){
    risk = "Ryzyko eskalacji: wysokie. Impuls = paliwo dla konfliktu.";
  } else if(emotion === "fear"){
    risk = "Ryzyko paraliżu: średnio-wysokie. Strach potrafi udawać rozsądek.";
  } else if(emotion === "sadness"){
    risk = "Ryzyko rezygnacji: średnie. Smutek spłaszcza opcje do „nic nie ma sensu”.";
  } else {
    risk = "Ryzyko błędnej interpretacji: średnie. Brak twardych danych = ryzyko złej decyzji.";
  }

  // Recommendation
  // If vague -> interrogate, not finish.
  const vague = isVague(text, score);

  if(vague){
    mem.vagueCount += 1;

    const press = [
      "Nie kończę na skróty — doprecyzuj.",
      "Nie będę wróżyć. Będę mierzyć.",
      "Bez konkretów nie ma planu. To nie jest złośliwość. To higiena decyzji."
    ];

    rec += press[Math.min(2, pushLevel)] + "\n";
    rec += "Oto 2 realne opcje, które zwykle istnieją w tle:\n";
    rec += "A) " + options.A + "\n";
    rec += "B) " + options.B + "\n\n";
    rec += "Teraz odpowiedz krótko (jednym zdaniem na punkt):\n";
    rec += "1) Co jest celem (jedno zdanie)?\n";
    rec += "2) Jakie są twarde ograniczenia (czas/pieniądze/zdrowie)?\n";
    rec += "3) Czego NIE akceptujesz (granica)?\n";
    rec += "Po tym zrobię plan na 7 i 30 dni — bez lania wody.";
  } else {
    // Enough info -> give plan (7/30)
    rec += "Dobra. Robimy decyzję kontrolowaną.\n";
    rec += "Najpierw ustawiam Ci dwie opcje (nie proszę — ja je stawiam):\n";
    rec += "A) " + options.A + "\n";
    rec += "B) " + options.B + "\n\n";

    rec += "PLAN 7 DNI:\n";
    rec += "• Dzień 1: Zapisz 3 fakty + 3 emocje + 1 cel. (Bez eseju.)\n";
    rec += "• Dzień 2: Jedna rozmowa/akcja testowa (20 min) według zasad. Notujesz wynik.\n";
    rec += "• Dzień 3: Ustal granicę i konsekwencję na papierze (jedno zdanie).\n";
    rec += "• Dzień 4–5: Powtórz test (drugi raz). Sprawdzasz, czy jest zmiana.\n";
    rec += "• Dzień 6: Decyzja wstępna: A czy B? (bez „zobaczymy”).\n";
    rec += "• Dzień 7: Ustaw próg STOP/GO (co musi się stać, by iść dalej).\n\n";

    rec += "PLAN 30 DNI:\n";
    rec += "• Tydzień 1: 2 testy + mierniki (reakcja, konsekwencja, koszt emocjonalny).\n";
    rec += "• Tydzień 2: Jeśli brak poprawy — wdrażasz konsekwencję bez dyskusji.\n";
    rec += "• Tydzień 3: Opcja A/B wybierasz w praktyce (jedno działanie dziennie, małe).\n";
    rec += "• Tydzień 4: Podsumowanie: zostajesz z tym czy wychodzisz? Uzasadnienie w 5 zdaniach.\n\n";

    rec += "Powiedz mi teraz jedno: wybierasz A czy B — i dlaczego w 1 zdaniu.";
  }

  // learning: remember topic/emotion
  mem.lastTopic = topic;
  mem.lastEmotion = emotion;
  mem.runs += 1;
  mem.topicCounts[topic] = (mem.topicCounts[topic] || 0) + 1;

  // return
  return { analysis, risk, recommendation: rec };
}

/* =========================
   Main analyze (DEMO)
========================= */
function analyze(){
  const input = document.getElementById("input");
  const text = input.value || "";
  const orb = document.getElementById("orb");

  if(!text.trim()){
    alert("Podaj konkret.");
    return;
  }

  const mem = loadMem();

  const score = scoreLex(text);
  const emotion = pickEmotion(score);
  const topic = pickTopic(score);

  // orb reacts to emotion immediately
  setOrbByEmotion(emotion);

  // show "thinking" via pulse
  orb.classList.add("active");

  setTimeout(()=>{
    // generate response
    const out = stanVoice(mem, emotion, topic, score, text);

    // persist learning
    saveMem(mem);

    // render
    document.getElementById("analysis").innerText = out.analysis;
    document.getElementById("risk").innerText = out.risk;
    document.getElementById("recommendation").innerText = out.recommendation;

    orb.classList.remove("active");
  }, 650);
}

/* =========================
   Utility buttons
========================= */
function forceRefresh(){
  // hard reload attempt (works in Safari too)
  location.reload(true);
}
</script>

</body>
</html>