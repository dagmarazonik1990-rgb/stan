<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>STAN</title>

  <meta name="theme-color" content="#0B0F1A" />
  <link rel="manifest" href="manifest.json" />

  <!-- iOS PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="STAN" />
  <link rel="apple-touch-icon" href="icon-192.png.PNG" />

  <style>
    :root{
      --bg1:#070A12; --bg2:#0B0F1A;
      --surface: rgba(255,255,255,.06);
      --surface2: rgba(255,255,255,.04);
      --stroke: rgba(255,255,255,.12);
      --text:#EAF0FF;
      --muted: rgba(234,240,255,.70);
      --muted2: rgba(234,240,255,.52);
      --a1:#7B5CFF;
      --a2:#B256FF;
      --good:#45D483;
      --warn:#F0C04A;
      --r:22px;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 10px 30px rgba(0,0,0,.38);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 700px at 65% 18%, rgba(178,86,255,.22), transparent 55%),
        radial-gradient(900px 520px at 22% 70%, rgba(123,92,255,.18), transparent 58%),
        linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 100%);
      padding: 22px 16px 40px;
      padding-top: max(22px, env(safe-area-inset-top));
      padding-bottom: max(40px, env(safe-area-inset-bottom));
    }

    .wrap{ max-width:560px; margin:0 auto; }
    .title{
      font-size:56px;
      line-height:.95;
      font-weight:900;
      letter-spacing:.02em;
      text-shadow: 0 14px 40px rgba(0,0,0,.45);
      margin: 8px 0 8px;
    }
    .subtitle{
      margin:0 0 18px;
      color: var(--muted2);
      font-size:20px;
      letter-spacing:.01em;
    }

    .hero{
      border-radius: var(--r);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      overflow:hidden;
      padding: 16px;
    }

    .rowTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:12px;
    }
    .rowTop h2{
      margin:0;
      font-size:22px;
      letter-spacing:.01em;
    }
    .pill{
      font-size:13px;
      color: rgba(234,240,255,.82);
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      padding: 8px 12px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
      white-space:nowrap;
    }

    /* AVATAR BOX (no white frame) */
    .avatarBox{
      width:100%;
      aspect-ratio: 1 / 1;
      border-radius: calc(var(--r) - 6px);
      border: 1px solid rgba(255,255,255,.12);
      background:
        radial-gradient(650px 420px at 50% 40%, rgba(178,86,255,.22), transparent 55%),
        radial-gradient(800px 520px at 50% 110%, rgba(123,92,255,.20), transparent 60%),
        rgba(0,0,0,.18);
      position: relative;
      overflow: hidden; /* klucz: ucina rogi PNG + ‚Äúbia≈Çe‚Äù */
      margin-bottom:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: var(--shadow2);
      isolation:isolate;
    }

    /* ORB (CSS) */
    .orb{
      width: 78%;
      aspect-ratio:1/1;
      border-radius: 999px;
      position: relative;
      filter: saturate(1.1);
      background:
        radial-gradient(circle at 35% 30%, rgba(255,255,255,.12), transparent 32%),
        radial-gradient(circle at 50% 55%, rgba(178,86,255,.55), rgba(123,92,255,.22) 55%, rgba(0,0,0,.55) 78%),
        radial-gradient(circle at 50% 50%, rgba(0,0,0,.20), rgba(0,0,0,.70) 85%);
      box-shadow:
        0 0 90px rgba(123,92,255,.32),
        0 0 160px rgba(178,86,255,.18),
        inset 0 0 40px rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.10);
      transform: translate3d(var(--orbX,0px), var(--orbY,0px), 0) scale(var(--orbS,1));
      animation: orbBreathe 5.8s ease-in-out infinite;
    }
    .orb::after{
      content:"";
      position:absolute;
      left:-12%;
      right:-12%;
      top:50%;
      height:3px;
      transform: translateY(-50%);
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.16), transparent);
      box-shadow: 0 0 22px rgba(178,86,255,.35);
      opacity:.8;
      animation: scan 3.6s ease-in-out infinite;
      border-radius: 999px;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    .orb::before{
      content:"";
      position:absolute;
      inset:-18%;
      background:
        radial-gradient(circle at 50% 50%, rgba(178,86,255,.10), transparent 55%);
      filter: blur(10px);
      opacity:.9;
      animation: aura 6.2s ease-in-out infinite;
      pointer-events:none;
    }

    @keyframes orbBreathe{
      0%,100%{ transform: translate3d(var(--orbX,0px), var(--orbY,0px), 0) scale(1); }
      50%{ transform: translate3d(calc(var(--orbX,0px) * 1.2), calc(var(--orbY,0px) * 1.2), 0) scale(1.035); }
    }
    @keyframes scan{
      0%,100%{ opacity:.55; transform: translateY(-50%) scaleX(.98); }
      50%{ opacity:.95; transform: translateY(-50%) scaleX(1.03); }
    }
    @keyframes aura{
      0%,100%{ opacity:.75; transform: scale(1); }
      50%{ opacity:1; transform: scale(1.08); }
    }

    /* SEMI (image + life) */
    .semiWrap{
      width:100%;
      height:100%;
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      border-radius: inherit;
      background: rgba(0,0,0,.18);
    }

    .semiImg{
      width: 100%;
      height: 100%;
      object-fit: cover;
      display:block;
      transform:
        translate3d(var(--sx,0px), var(--sy,0px), 0)
        scale(1.04);
      filter: saturate(1.04) contrast(1.02);
      will-change: transform;
    }

    /* ‚Äú≈ºywe oczy‚Äù bez grzebania w grafice */
    .eyeGlow{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:.0;
      mix-blend-mode: screen;
      background:
        radial-gradient(140px 80px at 45% 42%, rgba(120,220,255,.22), transparent 60%),
        radial-gradient(140px 80px at 55% 42%, rgba(120,220,255,.22), transparent 60%),
        radial-gradient(380px 260px at 50% 46%, rgba(178,86,255,.10), transparent 62%);
      animation: eyePulse 4.8s ease-in-out infinite;
    }
    @keyframes eyePulse{
      0%,100%{ opacity:.10; }
      45%{ opacity:.18; }
      55%{ opacity:.06; }
    }

    .blink{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:0;
      background:
        linear-gradient(180deg, transparent 0%, rgba(0,0,0,.35) 46%, transparent 60%);
      animation: blink 6.5s infinite;
      mix-blend-mode: multiply;
    }
    @keyframes blink{
      0%,92%,100%{ opacity:0; transform: translateY(-12px); }
      94%{ opacity:.55; transform: translateY(0); }
      96%{ opacity:0; transform: translateY(12px); }
    }

    /* Input */
    textarea{
      width:100%;
      min-height:112px;
      resize: vertical;
      border-radius:18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: var(--text);
      padding: 14px;
      font-size:16px;
      line-height:1.35;
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
    }
    textarea::placeholder{ color: rgba(234,240,255,.45); }

    .btn{
      width:100%;
      margin-top:12px;
      border:none;
      border-radius:18px;
      padding: 16px 18px;
      font-size:20px;
      font-weight:900;
      color:white;
      background: linear-gradient(90deg, var(--a1), var(--a2));
      box-shadow: 0 18px 50px rgba(123,92,255,.28);
      cursor:pointer;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }

    .row{
      display:flex;
      gap:10px;
      margin-top:10px;
    }
    .smallBtn{
      flex:1;
      border-radius:16px;
      padding: 12px 14px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(234,240,255,.88);
      font-weight:900;
      cursor:pointer;
      user-select:none;
    }
    .smallBtn.primary{
      background: linear-gradient(90deg, rgba(123,92,255,.35), rgba(178,86,255,.28));
      border-color: rgba(255,255,255,.14);
    }
    .smallBtn:active{ transform: translateY(1px); }

    .chips{
      margin-top:12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .chip{
      font-size:13px;
      color: rgba(234,240,255,.78);
      padding: 9px 12px;
      border-radius:999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      backdrop-filter: blur(10px);
    }
    .chip.good{ border-color: rgba(69,212,131,.35); }
    .chip.warn{ border-color: rgba(240,192,74,.35); }

    .grid{
      margin-top:16px;
      display:grid;
      gap:12px;
    }
    .card{
      border-radius:20px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      box-shadow: 0 12px 40px rgba(0,0,0,.30);
      padding: 16px;
    }
    .card h3{
      margin:0 0 8px;
      font-size:22px;
      letter-spacing:.01em;
    }
    .card .text{
      margin:0;
      color: rgba(234,240,255,.74);
      font-size:16px;
      line-height:1.45;
      white-space: pre-wrap;
    }

    /* STOPKA (disclaimer) */
    .footer{
      margin-top: 14px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,.08);
      color: rgba(234,240,255,.45);
      font-size: 12.5px;
      line-height: 1.35;
      letter-spacing: .01em;
    }
    .footer strong{ color: rgba(234,240,255,.65); font-weight: 900; }
    .footer a{ color: rgba(234,240,255,.55); text-decoration: none; border-bottom: 1px dotted rgba(234,240,255,.25); }
    .footer a:active{ opacity:.85; }

    /* USUWA ewentualny ‚Äúdymek/hint‚Äù, gdyby co≈õ zosta≈Ço */
    .hintBubble, #hintBubble{ display:none !important; }

    /* audio unlock overlay */
    .unlockOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 9999;
    }
    .unlockCard{
      width:min(520px, 92vw);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.20));
      box-shadow: var(--shadow);
      padding: 18px;
    }
    .unlockTitle{
      font-weight: 1000;
      font-size: 18px;
      margin: 0 0 6px;
    }
    .unlockText{
      margin: 0 0 12px;
      color: rgba(234,240,255,.75);
      line-height: 1.35;
      font-size: 14px;
    }
    .unlockRow{ display:flex; gap:10px; }
    .unlockRow button{
      flex:1;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      padding:12px 14px;
      font-weight:1000;
      color: rgba(234,240,255,.92);
      background: rgba(0,0,0,.25);
    }
    .unlockRow button.primary{
      background: linear-gradient(90deg, rgba(123,92,255,.55), rgba(178,86,255,.45));
      border-color: rgba(255,255,255,.18);
      color:white;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">STAN</div>
    <div class="subtitle">Agent decyzyjny AI ‚Ä¢ obecno≈õƒá</div>

    <div class="hero">
      <div class="rowTop">
        <h2>STAN avatar</h2>
        <div class="pill" id="avatarPill">Domy≈õlnie: ORB</div>
      </div>

      <div class="avatarBox" id="avatarBox" aria-label="STAN avatar">
        <!-- ORB -->
        <div class="orb" id="orb" aria-label="STAN orb"></div>

        <!-- SEMI -->
        <div class="semiWrap" id="semiWrap" aria-label="STAN semi-human">
          <img class="semiImg" id="semiImg" src="avatar-semi.PNG" alt="STAN semi-human" />
          <div class="eyeGlow"></div>
          <div class="blink"></div>
        </div>
      </div>

      <textarea id="input" placeholder="Opisz sytuacjƒô. Co siƒô sta≈Ço, co chcesz osiƒÖgnƒÖƒá, jakie masz ograniczenia?"></textarea>
      <button class="btn" id="analyzeBtn">Analiza ‚Üí</button>

      <div class="row">
        <button class="smallBtn primary" id="listenBtn">üéôÔ∏è S≈Çuchaj</button>
        <button class="smallBtn" id="speakBtn">üîä M√≥w</button>
        <button class="smallBtn" id="ambientBtn">üå´Ô∏è Ambient</button>
        <button class="smallBtn" id="stopBtn">‚èπÔ∏è Stop</button>
      </div>

      <div class="chips">
        <div class="chip warn" id="modeChip">Tryb: PRO (bez chamstwa)</div>
        <div class="chip good" id="pwaChip">PWA: ‚Äî</div>
        <div class="chip" id="voiceChip">Audio: ‚Äî</div>
        <div class="chip" id="verChip">Wersja: 20260224-02</div>
      </div>

      <div class="grid">
        <div class="card">
          <h3>Analiza</h3>
          <p class="text" id="analysis">Tu pojawi siƒô analiza.</p>
        </div>
        <div class="card">
          <h3>Ryzyko</h3>
          <p class="text" id="risk">Tu pojawi siƒô ocena ryzyka.</p>
        </div>
        <div class="card">
          <h3>Rekomendacja</h3>
          <p class="text" id="recommendation">Tu pojawi siƒô rekomendacja.</p>
        </div>
      </div>

      <!-- STOPKA / DISCLAIMER -->
      <div class="footer">
        <strong>Wa≈ºne:</strong> STAN jest asystentem decyzyjnym. Nie stawia diagnoz, nie zastƒôpuje lekarza/psychologa/prawnika i nie gwarantuje wyniku.
        Je≈õli sprawa dotyczy zdrowia, bezpiecze≈Ñstwa lub ryzyka prawnego ‚Äî skonsultuj siƒô ze specjalistƒÖ.
      </div>
    </div>
  </div>

  <!-- iOS: odblokowanie audio po ge≈õcie -->
  <div class="unlockOverlay" id="unlockOverlay">
    <div class="unlockCard">
      <p class="unlockTitle">Odblokuj audio</p>
      <p class="unlockText">
        iOS wymaga gestu u≈ºytkownika, ≈ºeby uruchomiƒá d≈∫wiƒôk i mikrofon.
        Kliknij poni≈ºej.
      </p>
      <div class="unlockRow">
        <button class="primary" id="unlockBtn">Odblokuj</button>
        <button id="unlockNoAmbientBtn">Tylko m√≥wienie</button>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const analyzeBtn = $("analyzeBtn");
    const input = $("input");
    const analysis = $("analysis");
    const risk = $("risk");
    const recommendation = $("recommendation");

    const avatarBox = $("avatarBox");
    const orbEl = $("orb");
    const semiWrap = $("semiWrap");
    const semiImg = $("semiImg");
    const avatarPill = $("avatarPill");

    const listenBtn = $("listenBtn");
    const speakBtn = $("speakBtn");
    const ambientBtn = $("ambientBtn");
    const stopBtn = $("stopBtn");

    const pwaChip = $("pwaChip");
    const voiceChip = $("voiceChip");

    const unlockOverlay = $("unlockOverlay");
    const unlockBtn = $("unlockBtn");
    const unlockNoAmbientBtn = $("unlockNoAmbientBtn");

    // ---------------------------
    // PWA detect
    // ---------------------------
    function isStandalonePWA(){
      return window.matchMedia("(display-mode: standalone)").matches ||
             window.navigator.standalone === true;
    }
    function setPwaChip(){
      pwaChip.textContent = "PWA: " + (isStandalonePWA() ? "TAK" : "NIE");
    }

    // ---------------------------
    // Avatar state + ‚Äúlife‚Äù
    // ---------------------------
    let avatarMode = "orb"; // "orb" | "semi"
    function renderAvatar(){
      if(avatarMode === "orb"){
        orbEl.style.display = "block";
        semiWrap.style.display = "none";
        avatarPill.textContent = "Domy≈õlnie: ORB";
      } else {
        orbEl.style.display = "none";
        semiWrap.style.display = "flex";
        avatarPill.textContent = "Premium: SEMI-HUMAN";
      }
    }

    // Long press: ~0.65s switch avatar
    let pressTimer = null;
    function onPressStart(){
      pressTimer = setTimeout(() => {
        avatarMode = (avatarMode === "orb") ? "semi" : "orb";
        renderAvatar();
      }, 650);
    }
    function onPressEnd(){
      if(pressTimer) clearTimeout(pressTimer);
      pressTimer = null;
    }

    avatarBox.addEventListener("pointerdown", onPressStart);
    avatarBox.addEventListener("pointerup", onPressEnd);
    avatarBox.addEventListener("pointerleave", onPressEnd);
    avatarBox.addEventListener("touchstart", onPressStart, {passive:true});
    avatarBox.addEventListener("touchend", onPressEnd);

    // Parallax
    function setParallax(clientX, clientY){
      const r = avatarBox.getBoundingClientRect();
      const nx = (clientX - (r.left + r.width/2)) / (r.width/2);
      const ny = (clientY - (r.top + r.height/2)) / (r.height/2);

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const x = clamp(nx, -1, 1);
      const y = clamp(ny, -1, 1);

      const orbX = (x * 6).toFixed(2) + "px";
      const orbY = (y * 6).toFixed(2) + "px";
      orbEl.style.setProperty("--orbX", orbX);
      orbEl.style.setProperty("--orbY", orbY);

      const sx = (x * 7).toFixed(2) + "px";
      const sy = (y * 5).toFixed(2) + "px";
      semiImg.style.setProperty("--sx", sx);
      semiImg.style.setProperty("--sy", sy);
    }

    window.addEventListener("pointermove", (e)=> setParallax(e.clientX, e.clientY));
    window.addEventListener("touchmove", (e)=>{
      const t = e.touches && e.touches[0];
      if(t) setParallax(t.clientX, t.clientY);
    }, {passive:true});

    // ---------------------------
    // Audio: SpeechSynthesis
    // ---------------------------
    const canSpeak = "speechSynthesis" in window;

    function setVoiceChip(txt){ voiceChip.textContent = txt; }

    function speak(text){
      if(!canSpeak) { setVoiceChip("Audio: brak TTS"); return; }
      try{
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "pl-PL";
        u.rate = 1.02;
        u.pitch = 0.92;
        window.speechSynthesis.speak(u);
        setVoiceChip("Audio: m√≥wienie ‚úì");
      } catch(e){
        setVoiceChip("Audio: b≈ÇƒÖd TTS");
      }
    }

    function stopAllAudio(){
      try{ if(canSpeak) window.speechSynthesis.cancel(); }catch(e){}
      try{ if(recognition) recognition.stop(); }catch(e){}
      try{ stopAmbient(); }catch(e){}
      setVoiceChip("Audio: stop");
    }

    // ---------------------------
    // Audio: SpeechRecognition
    // ---------------------------
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const canListen = !!SpeechRecognition;
    let recognition = null;
    let listening = false;

    if(canListen){
      recognition = new SpeechRecognition();
      recognition.lang = "pl-PL";
      recognition.continuous = false;
      recognition.interimResults = false;

      recognition.onresult = (ev) => {
        const txt = ev.results?.[0]?.[0]?.transcript || "";
        if(txt) input.value = (input.value ? input.value + "\n" : "") + txt;
        setVoiceChip("Mikrofon: OK");
        listening = false;
      };
      recognition.onerror = () => {
        setVoiceChip("Mikrofon: ERROR");
        listening = false;
      };
      recognition.onend = () => { listening = false; };
    }

    // ---------------------------
    // Ambient: WebAudio
    // ---------------------------
    let audioCtx = null;
    let ambientOn = false;
    let ambientNodes = null;
    let unlocked = false;

    function ensureAudio(){
      if(unlocked) return true;
      unlockOverlay.style.display = "flex";
      return false;
    }

    function unlockAudio(){
      try{
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        audioCtx.resume && audioCtx.resume();
        unlocked = true;
        unlockOverlay.style.display = "none";
        setVoiceChip("Audio: odblokowane ‚úì");
      }catch(e){
        setVoiceChip("Audio: nie da siƒô odblokowaƒá");
      }
    }

    unlockBtn.addEventListener("click", unlockAudio);
    unlockNoAmbientBtn.addEventListener("click", unlockAudio);

    function startAmbient(){
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      const ctx = audioCtx;

      const bufferSize = 2 * ctx.sampleRate;
      const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++){
        output[i] = (Math.random()*2 - 1) * 0.25;
      }
      const noise = ctx.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;

      const filter = ctx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 420;

      const windGain = ctx.createGain();
      windGain.gain.value = 0.0001;

      const hum = ctx.createOscillator();
      hum.type = "sine";
      hum.frequency.value = 58;

      const humGain = ctx.createGain();
      humGain.gain.value = 0.0001;

      const master = ctx.createGain();
      master.gain.value = 0.14;

      noise.connect(filter);
      filter.connect(windGain);
      windGain.connect(master);

      hum.connect(humGain);
      humGain.connect(master);

      master.connect(ctx.destination);

      let t0 = ctx.currentTime;
      windGain.gain.setValueAtTime(0.0001, t0);
      windGain.gain.linearRampToValueAtTime(0.020, t0 + 1.6);
      windGain.gain.linearRampToValueAtTime(0.012, t0 + 3.8);

      humGain.gain.setValueAtTime(0.0001, t0);
      humGain.gain.linearRampToValueAtTime(0.010, t0 + 2.0);

      noise.start();
      hum.start();

      ambientNodes = {noise, hum, master};
      ambientOn = true;
      setVoiceChip("Audio: ambient ‚úì");
    }

    function stopAmbient(){
      if(!ambientNodes) { ambientOn=false; return; }
      try{ ambientNodes.noise.stop(); }catch(e){}
      try{ ambientNodes.hum.stop(); }catch(e){}
      try{ ambientNodes.master.disconnect(); }catch(e){}
      ambientNodes = null;
      ambientOn = false;
      setVoiceChip("Audio: ambient off");
    }

    function toggleAmbient(){
      if(!ensureAudio()) return;
      if(ambientOn) stopAmbient();
      else startAmbient();
    }

    // ---------------------------
    // CORE: analyze (POST /api/analyze)
    // ---------------------------
    function safeText(s){
      return String(s || "").replace(/\u0000/g,"").trim();
    }

    function localHardcoreFallback(t){
      const base = t.length < 80
        ? "Daj jeszcze 2‚Äì3 zdania kontekstu (kto, co, kiedy, jakie stawki i ograniczenia)."
        : "";

      const analysisTxt =
`üß† ANALIZA (hardcore, ale fair)
Twoim celem nie jest ‚Äûpoczuƒá siƒô lepiej‚Äù, tylko podjƒÖƒá decyzjƒô, kt√≥rƒÖ ud≈∫wigniesz za 30 dni.
Najpierw oddzielam fakty od interpretacji.

FAKTY (to, co da siƒô sprawdziƒá):
‚Ä¢ Kto jest stronƒÖ? Co jest ustalone ‚Äûna pi≈õmie‚Äù/wprost?
‚Ä¢ Co siƒô wydarzy≈Ço w kolejno≈õci czasu?
‚Ä¢ Jakie sƒÖ twarde ograniczenia (czas, pieniƒÖdze, zdrowie, zasoby, reputacja)?

INTERPRETACJE / emocje (wa≈ºne, ale nie sƒÖ danymi):
‚Ä¢ Co dopowiadasz sobie o intencjach innych?
‚Ä¢ Co jest reakcjƒÖ obronnƒÖ (z≈Ço≈õƒá, lƒôk, poczucie winy)?

HIPOTEZA ROBOCZA:
Je≈ºeli masz chaos, zwykle problemem nie jest brak odwagi ‚Äî tylko brak kryteri√≥w i brak planu testu.
${base}`;

      const riskTxt =
`‚ö†Ô∏è RYZYKO
1) Ryzyko decyzji w afekcie: du≈ºa szansa, ≈ºe wybierzesz ulgƒô ‚Äûtu i teraz‚Äù, a nie wynik.
2) Ryzyko ≈õlepej plamki: pominiƒôcie jednego ograniczenia, kt√≥re potem wywraca ca≈Ço≈õƒá.
3) Ryzyko diagnozowania/oceniania ludzi: tego nie robimy ‚Äî pracujemy na zachowaniach i faktach.`;

      const recTxt =
`üß≠ REKOMENDACJA (plan operacyjny)

PLAN 7 DNI
1) Zapisz 3 opcje (nie dwie). Nawet je≈õli 3. jest ‚Äûpauza/odroczenie‚Äù.
2) Ustal 4 kryteria (skala 1‚Äì10): bezpiecze≈Ñstwo, koszt, czas, spok√≥j psychiczny.
3) Zr√≥b mikro-test: jeden ma≈Çy ruch, kt√≥ry daje dane (np. rozmowa, telefon, mail, pr√≥bka, demo, 30 min researchu).

PLAN 30 DNI
1) Wybierz opcjƒô z najlepszym ‚Äûstosunkiem spokoju do kosztu‚Äù.
2) Zablokuj powr√≥t do punktu 0 (deadline + nastƒôpny krok w kalendarzu).
3) Iteruj. Decyzja nie musi byƒá idealna ‚Äî ma byƒá ≈õwiadoma.

Je≈õli chcesz, doprecyzujƒô to w 2 pytaniach: (a) jaki jest cel, (b) jakie sƒÖ ograniczenia i stawka pora≈ºki.`;

      return { analysis: analysisTxt, risk: riskTxt, recommendation: recTxt };
    }

    async function callApi(text){
      const r = await fetch("/api/analyze", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text })
      });

      const data = await r.json().catch(()=> ({}));
      if(!r.ok){
        const msg = data?.error?.message || data?.error || ("HTTP " + r.status);
        throw new Error(msg);
      }
      return data;
    }

    async function run(){
      const t = safeText(input.value);
      if(t.length < 40){
        analysis.textContent = "Zatrzymaj chaos.\n\nDopisz:\n1) Cel\n2) Ograniczenia\n3) Opcje (A/B/C)\n\nNie zgadujƒô. Analizujƒô.";
        risk.textContent = "";
        recommendation.textContent = "";
        return;
      }

      analysis.textContent = "‚è≥ Analizujƒô‚Ä¶";
      risk.textContent = "‚è≥";
      recommendation.textContent = "‚è≥";

      try{
        const out = await callApi(t);
        analysis.textContent = out.analysis || "";
        risk.textContent = out.risk || "";
        recommendation.textContent = out.recommendation || "";

        if(unlocked) speak(recommendation.textContent);
      } catch(err){
        const fallback = localHardcoreFallback(t);
        analysis.textContent = fallback.analysis;
        risk.textContent = fallback.risk + "\n\n(Info: API chwilowo niedostƒôpne ‚Äî tryb awaryjny, bez diagnoz.)";
        recommendation.textContent = fallback.recommendation;

        if(unlocked) speak(recommendation.textContent);
      }
    }

    // ---------------------------
    // Events
    // ---------------------------
    analyzeBtn.addEventListener("click", run);

    listenBtn.addEventListener("click", ()=>{
      if(!ensureAudio()) return;
      if(!canListen){
        setVoiceChip("Mikrofon: BRAK (iOS PWA czƒôsto nie wspiera)");
        return;
      }
      try{
        if(listening){ recognition.stop(); listening=false; return; }
        recognition.start();
        listening=true;
        setVoiceChip("Mikrofon: s≈Çucham‚Ä¶");
      }catch(e){
        setVoiceChip("Mikrofon: ERROR");
      }
    });

    speakBtn.addEventListener("click", ()=>{
      if(!ensureAudio()) return;
      const t = [analysis.textContent, risk.textContent, recommendation.textContent].join("\n\n").trim();
      if(t) speak(t);
    });

    ambientBtn.addEventListener("click", toggleAmbient);
    stopBtn.addEventListener("click", stopAllAudio);

    window.addEventListener("pointerdown", ()=>{
      if(!unlocked) unlockOverlay.style.display = "flex";
    }, {once:false});

    // init
    setPwaChip();
    renderAvatar();
    setVoiceChip(canSpeak ? "Audio: gotowe (tap to unlock)" : "Audio: brak TTS");
    setParallax(window.innerWidth/2, window.innerHeight/2);
  </script>
</body>
</html>